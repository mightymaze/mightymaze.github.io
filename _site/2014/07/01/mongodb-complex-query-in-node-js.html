<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Quicksand|Nunito:300,400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/css/style.css?v="
          media="screen" type="text/css">
    <link rel="stylesheet" href="/assets/css/print.css" media="print" type="text/css">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!--<title>Mazhar's Blog by </title>-->

    <!-- Begin Jekyll SEO tag v2.1.0 -->
<title>MongoDB complex query in Node.JS - Mazhar’s Blog</title>
<meta property="og:title" content="MongoDB complex query in Node.JS" />
<meta name="description" content="As you guys already know that MongoDB isn’t suitable for complex queries. There are couple of ways to do it like Map-Reduce. But they will turn the whole application slow. So we can’t do that as we use MongoDB and Node.JS for couple of facilities and speed is one of them. So the best solution is to do it programmatically. Let’s see how to do it." />
<meta property="og:description" content="As you guys already know that MongoDB isn’t suitable for complex queries. There are couple of ways to do it like Map-Reduce. But they will turn the whole application slow. So we can’t do that as we use MongoDB and Node.JS for couple of facilities and speed is one of them. So the best solution is to do it programmatically. Let’s see how to do it." />
<link rel="canonical" href="http://localhost:4000/2014/07/01/mongodb-complex-query-in-node-js.html" />
<meta property="og:url" content="http://localhost:4000/2014/07/01/mongodb-complex-query-in-node-js.html" />
<meta property="og:site_name" content="Mazhar’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-07-01T17:37:30+06:00" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "MongoDB complex query in Node.JS",
"datePublished": "2014-07-01T17:37:30+06:00",
"description": "As you guys already know that MongoDB isn’t suitable for complex queries. There are couple of ways to do it like Map-Reduce. But they will turn the whole application slow. So we can’t do that as we use MongoDB and Node.JS for couple of facilities and speed is one of them. So the best solution is to do it programmatically. Let’s see how to do it.",
"url": "http://localhost:4000/2014/07/01/mongodb-complex-query-in-node-js.html"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
<header>
    <div class="inner">
        <a href="http://localhost:4000/">
            <h1>Mazhar's Blog</h1>
        </a>
        <h2>Entrepreneur, Product Enthusiast, Tech Expert, Designer, Brander
</h2>
        
        
    </div>
</header>

<div id="content-wrapper">
    <div class="inner clearfix">
        <section id="main-content">
            <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="post-header">
    <h1 class="post-title" itemprop="name headline">MongoDB complex query in Node.JS</h1>
    <p class="post-meta"><time datetime="2014-07-01T17:37:30+06:00" itemprop="datePublished">Jul 1, 2014</time></p>
  </div>

  <div class="post-content" itemprop="articleBody">
    <p>As you guys already know that MongoDB isn’t suitable for complex queries. There are couple of ways to do it like Map-Reduce. But they will turn the whole application slow. So we can’t do that as we use MongoDB and Node.JS for couple of facilities and speed is one of them. So the best solution is to do it programmatically. Let’s see how to do it.</p>

<p>Suppose we’ve two MongoDB collections like:</p>

<p><strong>Stores</strong></p>
<pre class="brush: sql;">
{
    "id": "id",
    "name": "store name",
    ...
}
</pre>

<p><strong>Extras</strong></p>
<pre class="brush: sql;">
{
    "id": "id",
    "store": "store id here",
    "address": "store address here",
    ...
}
</pre>

<p>So, now we wanna join the two tables to gather the total information about the store. Now let’s do our homework, let’s try to do this.</p>

<p>###Trial 1</p>

<pre class="brush: javascript;">
// we want our result here
// var store = ...
stores.findOne(id, function gotStore(firstRes) {
	extras.findOne(firstRes.id, function gotExtra(secondRes) {
		// So we've all data here
	});
});
</pre>

<p>Now the problem is how to sync the process so that we can get the data and don’t get the NULL. So this system isn’t working as we are getting NULL at the end. Let’s see what we can do with it.</p>

<p>###Trial 2</p>

<p>As we are using Node.js 0.10 we can’t use generators. Let’s go deep in the callback hell.</p>

<pre class="brush: javascript;">
function getStore(id, callback) {
    stores.findOne(id, function gotStore(firstRes) {
	    extras.findOne(firstRes.id, function gotExtra(secondRes) {
	    	// So we've all data here
	    	var result = firstRes.concat(secondRes)
	    	callback(result);
	    });
    });
}
</pre>

<p>So now we are getting the values asynchronously we can do our job like this:</p>

<pre class="brush: javascript;">
getStore(100, function printStore(store) {
    console.log (store.name);
});
</pre>

<p>There is almost 4 callback functions. That’s Okay for this sample as this sample is short. Real projects are too big and there will be a mess of callback functions. This is called Callback hell.</p>

<p>There are couple of ways to deal with Callback hell. Read my article about <a href="http://mazharahmed.me/solve-callback-hell-in-node-js/">solving Callback Hell in Node.js</a></p>

<p>Thanks. Good luck with your own work.</p>

  </div>

</article>

        </section>

        <aside id="sidebar">
            

            

            <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</p>

            <ul class="tags">
                
            </ul>

        </aside>
    </div>
</div>


</body>
</html>
